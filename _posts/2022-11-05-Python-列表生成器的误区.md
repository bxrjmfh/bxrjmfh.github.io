---
layout: post
title: Python åˆ—è¡¨ç”Ÿæˆå™¨çš„è¯¯åŒº
categories: pytå­¦ä¹ è®°å½•
tags: python æ•´ç†æ±‡æ€» è§£æƒ‘
---
# Python åˆ—è¡¨ç”Ÿæˆå™¨çš„è¯¯åŒº

åœ¨å†™ä»£ç çš„æ—¶å€™ï¼Œå¸Œæœ›æ„é€ ä¸€ä¸ªåµŒå¥—çš„åˆ—è¡¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

![image-20221105204149487](https://lh-picbed.oss-cn-chengdu.aliyuncs.com/image-20221105204149487.png)

äºæ˜¯è¿™ä¹ˆå†™ï¼š

```python
asoul = [[x,i] for x in range(len(arr)) for y in arr]
```

çœ‹ç€ä¼¼ä¹æ²¡å¤šå¤§æ¯›ç—…,ä½†æ˜¯è¿è¡Œåå‘ç°ä¸å¯¹åŠ²ï¼š

â€‹	![image-20221105204408408](https://lh-picbed.oss-cn-chengdu.aliyuncs.com/image-20221105204408408.png)

å¥½å¥½çš„asoulå˜æˆäº†ç¬›å¡å°”ç§¯ã€‚å›å¤´ä¸€çœ‹è‡ªå·±çš„ä»£ç æƒ¨ä¸å¿ç¹ï¼Œå¯¹äºç´¢å¼•å’Œæ•°å­—ç»“åˆçš„å½¢å¼ï¼Œè¦ç”¨ä¸‹é¢çš„å†™æ³•ï¼š

```python
asoul = [[x,i] for x in range(len(arr)) for y in arr]
```

è¿™æ ·æ‰æ˜¯ç®€æ´æ˜äº†çš„ã€‚

## to fix

```python
# Given an array of integers nums and an integer target, return indices of the 
# two numbers such that they add up to target. 
# 
#  You may assume that each input would have exactly one solution, and you may 
# not use the same element twice. 
# 
#  You can return the answer in any order. 
# 
#  
#  Example 1: 
# 
#  
# Input: nums = [2,7,11,15], target = 9
# Output: [0,1]
# Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
#  
# 
#  Example 2: 
# 
#  
# Input: nums = [3,2,4], target = 6
# Output: [1,2]
#  
# 
#  Example 3: 
# 
#  
# Input: nums = [3,3], target = 6
# Output: [0,1]
#  
# 
#  
#  Constraints: 
# 
#  
#  2 <= nums.length <= 10â´ 
#  -10â¹ <= nums[i] <= 10â¹ 
#  -10â¹ <= target <= 10â¹ 
#  Only one valid answer exists. 
#  
# 
#  
# Follow-up: Can you come up with an algorithm that is less than 
# O(nÂ²) time complexity?
# 
#  Related Topics Array Hash Table ğŸ‘ 39774 ğŸ‘ 1281


# leetcode submit region begin(Prohibit modification and deletion)
class Solution(object):
    def quickSort(self, arr, left=None, right=None):
        left = 0 if not isinstance(left, int) else left
        right = len(arr) - 1 if not isinstance(right, int) else right
        if left < right:
            partitionIndex = partition(arr, left, right)
            quickSort(arr, left, partitionIndex - 1)
            quickSort(arr, partitionIndex + 1, right)

    def partition(self, arr, left, right):
        pivot = left
        index = pivot + 1
        while i <= right:
            if arr[i] <= right:
                swap(arr, i, index)
                index += 1
            i += 1
        swap(arr, pivot, index - 1)
        return index - 1

    def swap(self, arr, left, right):
        arr[left], arr[right] = arr[right], arr[left]

    def getTwo(self, arr):
        return arr[1]

    def biSearch(self, arr, toFind, left=0, right=None):
        # return index in sorted list
        right = len(arr) - 1 if right is not isinstance(right, int) else right
        if left>right:
            return None
        if arr[left][1]==toFind:
            return left
        elif arr[right][1]==toFind:
            return right

        mid = (left + right) // 2
        if arr[mid][1] == toFind:
            return mid
        elif left == right:
            return None
        elif arr[mid][1] < toFind:
            return self.biSearch(arr, toFind, mid + 1, right)
        elif arr[mid][1] > toFind:
            return self.biSearch(arr, toFind, left, mid - 1)


    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        a = len(nums)
        pairs = [[x, y] for x, y in enumerate(nums)]
        pairs.sort(key=self.getTwo)
        for i in range(a):
            # i is also sorted index
            toFind = target - pairs[i][1]
            index = self.biSearch(pairs, toFind)
            # sorted index
            if not isinstance(index, int):
                continue
            if index == i:
                return [pairs[i][0], pairs[index - 1][0]] if pairs[index - 1][1] == pairs[i][1] else [pairs[i][0],
                                                                                                      pairs[index + 1][
                                                                                                          0]]
            return [pairs[i][0], pairs[index][0]]


# leetcode submit region end(Prohibit modification and deletion)

arr = [0,3,-3,4,-1]
target = -1
s = Solution()
res = s.twoSum(arr, target)
print(res)

```

